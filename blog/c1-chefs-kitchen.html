<!DOCTYPE>
<html>
<head>
  <link type="text/css" rel="stylesheet" href="../stylesheets/blog-stylesheet.css">
  <title>rkartzman</title>
</head>
<body>
 <nav>
    <ul>
      <li>
        <a href="http://rkartzman.github.io/index.html">HOME</a>
      </li>
      <li>
        <a href="http://rkartzman.github.io/c1-chefs-kitchen.html">BLOG</a>
      </li>
      <li>
        <a href="http://rkartzman.github.io/about-page.html">ABOUT</a>
      </li>
      <li>
        <a href="http://rkartzman.github.io/people-i-follow.html">PEOPLE I FOLLOW</a>
      </li>
    </ul>
  </nav>
  <article>
    <h2>Socratic Questioning</h2>
    <hr>
  <p>Socrates was famous for his precise method of asking questions in order to arrive at the truth. Most of Plato's writing are in the form of dialogues between his mentor Socrates and a character of classical Greek society of perceived wisdom. The conversation usually concludes with Socrates, through deductive reasoning and pointed questioning, convince the public figure that the conclusions they hold to be true are indeed incorrect.</p>

<p>The internet we know today, or rather the idea of the search engine in general is built on the notion of asking questions and receiving a response from someone or some source that might provide some context towards your enlightenment.</p>

<p>When we search for information on Google or Yahoo, to some extent we query the answer. You have to know what you are looking for in order to get the proper answer. While it is entirely possible to arrive at a biography of Ernest Hemingway, it is unlikely that you will get there unless you ask the right question, "Who wrote the book For Whom the Bell Tolls?"</p>

<p>Incidentally, I very recently came across the blog of the guy who started Stack Overflow, Jeff Atwood, which is an enourmous online forum for people who have questions about code they are writing. All of the answers are contributed by users of the site, people who have experienced similar problems themselves and came across potential solutions.</p>

<p>In other words its a question and answer site, and all of the participants are programmers. Like the internet itself, stack overflow is exceedingly large, therefore in order to get an answer it is critical to ask the right questions.</p>

<p>Atwood blogged about his initial intentions for the site, writing that in his mind he always viewed software development as a "collaborative game, where the only way to win is to learn from each other."</p>

<p>As a sidenote, I find my encounter with all of this to be ironic and oddly serendipitious, but hey the internet is cool like that sometimes.</p>

<p>Stack Overflow is in essence the modern Socratic dialogue for programmers. The wisest and most skilled continue to ask questions not out of ignorance but out of true understanding of the problem and a clear vision of the path to a solution.</p>

<p>Moving forward towards my plunge into software development I am going to be concious of the way in which I phrase my questions, to look for answers to smaller pieces of the big puzzle in order to construct a more visible end product.</p>


  </article>
<article>
  <h2>My Personal Source Code</h2>
    <hr>

<p>
Leading up to my college graduation, and shortly thereafter, my biggest flaw was ironically the value I find most important to me now. Curiousity and adventure(intellectual and physical) have become part of my personal constitution throughout my early adulthood. It is the reason I chose a liberal arts education, and the reason I so heavily emphasize the experience of travelling and doing activities outside of one's comfort zone. While others quickly reduce this to a lack of focus, or indecisiveness, I think it is absolutely essential to have the curiousity to dabble in areas I know very little about. Those invaluable experiences have shaped my worldview, humbled me, and serendipitously introduced me to people much wiser than me. Which is why I hope to continue to live by this creed, to constantly pursue areas that interest me, regardless of whether it seems "practical" at the moment.</p>

<p>Part of this personal philosophy inherently involves adopting the mentality of "what's the worst that could happen." I prefer the positive converse: regardless of the outcome, there is some discernible benefit. Adopting this mentality eliminates failure as an option because it rewards effort and it elevates the experience and the process above the outcome.</p>

<p>At DBC, it will be easy to fall victim to the trap of using one's classmates as perfomance indicators. This is a terrible strategy and will always result in effacing oneself. It will be critical to remember that everyone is on their own journey towards an irrelevant and independent outcome. It would be impossible and inhuman for us to be evaluated in a vaccuum on our relative capabilities, and therefore it is useless to think about the experience outside of our personal growth and development.
</p>
</div>

</article>

<article>
  <h2 class="recents">Recent Posts</h2>
  <h2>Java Jolt: First Impressions of the language of the Web</h2>

<p>
  Over the past several weeks I've been getting acquainted with the Ruby programming language as part of my phase-0 prep work for Dev Bootcamp. My Ruby coding skills are still dubious; I can build some basic programs, like an underwhelming and not so practical, virtual grocery shopping list. I reached a proficiency level on par with ordering pizza in Italy. It probably sounds insulting, but it gets the job done.</p>

<p>Over the past week, I've put a hold on my Ruby acquisition and made a transition to JavaScript, often heralded as the de facto "language of the web". Upon first inspection, JavaScript looks something of a burden with its decidedly long form syntax compared to the eloquent Ruby.</p>

<p>My impression with JavaScript has ironically been really enjoyable. I don't have a CS background, and for my entire undergrad career, conciously avoided any type of mathematical thinking. Programmers will often declare that you don't need to be good at math in order to code. This is largely true. Even a superficial understanding of mathematical operations will suffice in the programming world. But there is a mathematical style of thinking involved that takes some adjusting to, breaking problems into digestible bits that each serve an independent purpose.</p>

<p>Ruby is regarded by beginners as very relatable to the English language. Sometimes this can be overwhelming when Ruby offers a variety of ways to say the same thing. Thus JavaScript becomes the formulaic alternative that requires more detailed and less flexible syntax. Unfortunately, when you want just want pizza and while "I want pizza", "Pizza I want", and "want Pizza me" will likely result in a satiated appetite, sometimes it would be easier if there were just one correct combination of words.</p>
<p>
JavaScript provides that proper structure to me.
</p>

In Ruby, in order to create a Hash data structure you would write:

<pre><code>
h = {}
h['a'] = 1
h['b'] = 2

h.each {|key, value| puts "#{key} #{value}" }
</code></pre>

Creating a Hash in JS is almost identical:
<pre><code>
var h = {};
h['a'] = 1;
h['b'] = 2;

for (key in h) { console.log(key, h[key]); }
</code></pre>

Manipulating the hash is nearly the same as well.
But the real differences between the two languages do not bear themselves out between objects of the same type. If we look back at the Ruby syntax for creating a Hash, it is also remarkably similar to the way simple objects are created in JavaScript. For example to create a store object in JavaScript the proper syntax would be:

<pre><code>
var store = {
  name: "Coffeeshop",
  items: 40,
  typesAvailable: 10,
  fairTrade: true
}
</code></pre>
<p>
the properties of the store object each have a key and value similar to how a hash stores that data.
</p>
<p>
Ruby may have a more succinct way of creating objects, but to me it seems logical to simulatenously define an object alongside its properties in this fashion, similar to how an architect would draw up a blueprint for a house that will later be modified.
</p>
<p>
I'm sure as I progress I will revert back to my affection for concise Ruby syntax, but for the time being I'm liking the structured environment in JavaScript. To each his own. Time will tell.

</p>


</div>
</article>
<article>
  <h2>Classes in Ruby</h2>

<p>
  Almost every resource I have used during my introduction the Ruby programming language has relied on two dictums to convey its teachings. One is that Ruby is an Object Oriented language, and the other is that "everything in Ruby is an object". Clearly both of these are related, however they are not necessarily always used in conjuction with one another.  New programmers are also often told that Ruby is perhaps the easiest language to pickup due to its simplicity and english like syntax. This can be true, but like the English language, the various idiosyncracies are often paradoxical, often contradicting themselves. The idea that everythign in Ruby is an object, suggests that every aspect of the language is equivalent--related somehow in the way that people are all human beings and apples and oranges are both fruit.</p>
<p>
  For the most part this is true at the most basic level in Ruby. On the other hand, I was recently introduced to the concept of classes, which skews this logic, adding an aditional layer of complexity to the way one should design their programs in Ruby if they plan to make it flexible and adaptable over the long run. In other words, classes allow you to create kinship in Ruby whereby a sort of inheritance is transposed across objects, ultimately allowing separate objects contain the same data.</p>

<p>
In other words it allows you to access all the methods, and instance variables of a parent class. Sandy Metz, author of "Practical Object Oriented Design in Ruby" calls inheritence "a mechanism for automatic message delegation." While this may abstract the idea of classes it also implies a neat organizational structure of superclasses and their subclasses into something akin to a family tree. The example she uses is one of a Bicycle superclass with Roadbike and Mountainbike subclasses that inherit many of the behaviors of their parent class. Ruby differs from the traditional biological model however. Whereas it is natural to think of a child as having two parents from which it inherits its traits and behavioral makeup, objects in Ruby contain only a single inheritance, that is one superclass parent. Otherwise, Ruby would have to cross check more than container object in order to establish where the automated behavior is intended to derive from creating many confusions from Ruby to understand where to send its messages.</p>

<p>The syntax is rather simple when creating classes. Below is an oversimplification of what class inheritance would look like in Ruby. The key points to remember are: classes begin with a capital letter, they must be created along with an initialize method, and inheritance is described using the < symbol to denote subclass to the left and superclass to the right of the symbol.The initialize method is a function that will be called when a new object of that class is created. Ruby will do then add its secret sauce to that object.</p>
<pre><code>
class Fruit

  def initialize()
    @instance = instance
  end

  def method1
  end
class Apple < Fruit

  def initialize()

  end

  def method2

  end
end
</code></pre>

<p>Now when a new object apple = Apple.new() is created it will inherit all of the behaviors/attributes of the parent fruit class including access to all of its instance variables. Messages can then be sent to the object apple using dot. notation like any othe object in Ruby.</p>

<p>Classes can be a useful tool, but should be designed with careful attention to their flexibility over time. A superclass that is overly specific can ultimately create confusion and unintended overlaps in the inherited behaviors of their children.

</p>
</div>


</article>

<article>
  <h2>Thoughts on Stereotype Threat</h2>
  <p>
 The idea of the stereotype threat, introduced by psychologist Claude Steele offers a counterintuitive explanation to why certain groups, particularly minorities, underperform. While many of his studies have focused on standardized test results among women and African Americans, his theories can extend far beyond testing to individual underperformance in various aspects of life.</p>
<p>
I don't think it would be very difficult for anyone to think of a social setting in their own lives in which they felt fearful of how others might perceive them. This manifests in a fear of being considering incompetent in one's profession or even around the family dinner table when a discussion arises about a current event.</p>
<p>
Even thoughout college I was always hesitant to chime in on class discussions, holding my comments in for a time when I could engage in the discourse with absolute conviction in my points.</p>
<p>
As a social species, we all at some point experience this fear of confirming the negative stereotypes that colleagues, friends and family may have about us. There is a fear of being found out, of others realizing what they assumed to be true all along, that we are inadequate. Whether or not these stereotypes actually exist outside the boundaries of our own minds is unrelated to the idea that the negative environments we create on our own are self-limiting to our personal growth and development. On a societal scale, this theory can perhaps inform many of the debates regarding gender and race disparities in the workplace. The absence of women filling roles at technology companies is currently one of the most contentious issues in Silicon Valley, and the stereotype of the white frat boy culture at tech companies continues to stir the proverbial pot.
</p>
<p>
Claude Steele's research can ironically be a source of comfort if one allows it. While a lot is left open to interpretation as well as placing the honus on society to cultivate environments in the classroom and the workplace to minimize the presence of those negative stereotypes, there is a great deal of honus placed on the individual to be cognizant of how detrimental these negative stereotypes can be to our personal success and thus being proactive about ignoring them. Putting too much effort into proving others wrong would be to swim upstream. The ability to control the internal dialogue is a difficult skill, but one that can having massive upsides for our personal success and happiness.
</p>
</div>

</article>

<article>
  <h2>Unpretentious Observations of Classes in Ruby</h2>
  <hr>

<p>
  Less than a week ago, I had a really poor grasp of how to create classes in Ruby. While I had done some reading in David Black's "Well Grounded Rubyist" and my due diligence of online research, it is really difficult for me to commit these practices to muscle memory unless I am actually in the muck getting my hands dirty with some code. Naturally I felt overwhelmed and stifled by these abstractions of the Ruby language. Thus, I needed to go back to the building blocks of the language to make sure I understood these core concepts. And by this I mean literal square one, kindergarten show-and-tell philosophical discussions about characteristics and behaviors of real-world physical objects. And in terms of relateable objects, there are few things more universal than a car. I can't take full credit for this example, it is somewhat hackneyed, and I collaborated with a DBC mentor on this one, but it is really enlightening when learning the basics of creating our own classes in Ruby. Before even diving into Class specifics, its important to look at objects in terms of their properties and behaviors. First, ask questions such as What is car? Generally, what do all cars have? And what does a car do?
</p>
<p>
What is a car?
* Wheels, doors, seats, windows, engine, gears, etc. <--- has-a relationship defines composition
</p>
<p>
What do all cars have?
* Make, model, color, mileage, year <-- properties of a car | instance variables
</p>
<p>
What does a car do?
* drives, carry things, stop <-- behaviors | instance methods
</p>
<p>
Without having even coded anythign yet, we have a general idea of what our class of Cars would look like and a roadmap of where the code might take us. Based on these descriptions we have already defined what our properties are. These data will be contained within our instance variables. And on the other hand, we have defined the specific behaviors that cars have. These data will be contained within our instance methods. Another way to think about instance variables, is to think of them in terms of reusable bits of code that provide information about them that the methods can in turn use in order to carry out specific behaviors.
</p>
<p>
In the car class, we said that make, model, color and year were all properties of the class car, but would need to be further defined in order to refer to a specific car. The next step would be to create methods, or behaviors, for the car class so that when we further specificy some of the characteristics of our car, the method can take that information and generate those given behaviors. Perhaps the car might drive, and maybe count mileage.
</p>
<p>
In Ruby the aforementioned car class would look something like this:
</p>
<pre><code>
class Car

    def initialize(make,model,color,year)
        @make = make
        @model = model
        @color = color
        @year = year
    end

    def drive(num_of_miles)
        mileage += num_of_miles
    end
end

my_jeep = Car.new("Jeep","Patriot","silver",2014)
my_jeep.drive
my_jeep.color


</code></pre>


<p>
The bit after closing the class is how you create a new object of that class. The syntax is:
 obj = Obj.new
</p>
<p>
 You can see where the specific attributes are defined in the new object my_jeep. "Jeep", "Patriot", "silver", 2014 are the instance variables which are specific to the object my_jeep, but when the car class methods are called upon my_jeep it behaves in the same way any car of the car class would. Such is the utility of creating classes in programs. It allows you to define methods and variables that generally speaking are universal to all the objects of that class. By the same token, convertibles and pickup trucks drive in the way any car does, and they all have four wheels and use gas, but there are various makes, models and years for those types of cars. Creating classes adds to the logical flow of a program, instead of detracting from it. It makes the code readable to someone who might not know without reading every line of code what the method drive is referring to, but after seeing that it belongs to a certain class, has a much better understanding of what the outcome of the code might be.
</p>


</div>


</article>
<article>
  <h2>Feedback, Pairing and Growth</h2>
  <hr>

<p>
  Pairing and feedback are both vital components of the DBC experience as well as the journey towards becoming an adequate programmer. In most aspects of life, feeback is ironically something we tend to fear despite it being so valuable to our own personal growth. It's frightening to hear other people criticize your work and the tremendous effort that went into producing it. But in learning to program, I have found it to be indispensible. That vulnerability that I am accustomed to feeling has seemed much less important in recent weeks. I find myself feeling more comfortable with the criticism/or praise I receive from my colleagues. Part of this has to do with the feedback model provided by DBC, which requires comments about fellow cohorts to be Actionable, Specific, and Kind. The tripartite formula makes for truly cosntructive criticism that helps frame each suggestion as soemthing that is a natural part of the growing process, instead of a damning and fatalistic encapsulation of your programmer identity.
</p>
<p>
  There is a piece by Ira Glass, in my opinion one of the greatest storytellers of this generation, who explains this so called "gap" between your "killer taste" and the not so great work that you are producing. He argues that everyone goes through this trough and the only way to bring your work up to the level of your taste, is counterintuitively, to do a lot of work.
</p>
<p>
  It can be incredibly discouraging to continually do work that you know is inadequate(at least according to your killer taste), however paired programming and receiving feedback has motivated me to keep putting my work out there and to work through challenges with my colleagues. This inevitably leads to a better understanding of the creative process, and an even clearer and obvious comprehension of your thoughts. The ability to have a fresh set of eyes look at your logic and point out gaps/inconsistencies is invaluable to making breakthroughs and avoiding going down the proverbial rabbit hole.
</p>

</div>


</article>


<article>
  <h2>Conflicts</h2>
    <div class= "2">27 Nov 2014</div>
  <hr>
  <p>"If you can't feed a team with two pizzas, it's too large"
    --Jeff Bezos</p>
<p>
Immediately after I graduated from college I travelled to Northern Ghana to take part in implementing a water treatment business that would serve as a sustainable source of clean drinking water to a rural village. There were around 30 individuals volunteering through this organization. We were divided into small groups and each assigned one village that we would work closely with over the course of the program.
</p>
<p>
The villages are small self-sufficient communities, but they usually do not exceed 60-70 people. Including our translator, our group consisted of four people. I was the only male on the team. Northern Ghana is heavily Muslim, and a patriarchal dominated society. For this reason, I was typically the one leading the formal negotiations between our team and the chief and elders of the village.
</p>
<p>
It is fairly uncommon for young twenty somethings to travel to an austere environment with very little support. In my own observations, most of the people volunteering with me were motivated, ambitious and comfortable leaving their comfort zones. And the villagers were ecstatic to have each of there to help in any capacity we could.
</p>
<p>
Thus, every opportunity to interact with the villagers was a chance to shine, to be the Lebron James playing in a basketball tournament in China.
</p>
<p>
While there were never any flare ups or team arguments, there was tension boiling--which is sometimes worse. Perhaps it was a non-existent power struggle of my own imagination, negligeble in size and reality. But it inevitably lead to departmentalization of group roles instead of an equitable power sharing dynamic.
</p>
<p>
I think I personally could have done a better job of vocalizing my goals and expectations of what leadership roles I wanted to fill.
</p>
<p>
I handled the situation by subtly directing the spotlight in my teammates direction during other tasks throughout the implementation of the water business. My intention was to make each member of the group feel indispensible to some part of the process and to feel needed by the villagers.
</p>
<p>
I regret not having that discussion with everyone at the first sign of a division of responsibilities.
</p>
<p>
When working in teams in the future, I find it crucial to be concisious of individual personalities within the group. This will have major implications for the cohesiveness of the team. Addressing individual concerns, expecatitions and desired responsibilities early on can go a long way in maintaining the team synergy before it unintentionally degenerates into a top-down "works-for" instead of "works-with" mentality devoid of ego.
  </p>
</article>
<article>
  <h2>In Tech, (Seldom) Do We Trust</h2>
  <div class= "2">2 Nov 2014</div>
  <hr>
  <p>"Don't let the perfect be the enemy of the good"
    --Voltaire</p>
  <p>The single most important problem facing the tech industry right now is trust. Especially now, when the term "tech" is ambiguous itself. How do we define technology in 2014? Surely, tech has evolved from our traditional descriptions most often associated with rocketships, flying cars, computers and mobile phones. Search engines, mobile apps and 140 characters seems to be the focus now. But regardless of how you choose to characterize tech, ultimately the people have lost trust in society's ability to deliver on its promises, and somehow technology has somehow become the scapegoat. But unfortunately for those reluctant to adapt, every industry imaginable, from healthcare to financial services to government and national defense increasingly relies on software to store data, carry out fiduciary transactions and even conduct remote military operations through unmanned weapons. In short, technology is unavoidable, frightentingly pervasive. This inevitably blurs the lines between what we as citizens consider to be within the scope of our personal privacy and public information. Rarely do we feel secure entering our information on websites or the reliability of technology to control the security in our homes, whether it is by locking our front door right from our cell phones or entrusting a peer to peer transaction over Airbnb.

On the other hand, I certainly would not trade my occasional uncertainity and mistrust to not be able to participate in the technology economy. In order to reap the benefits, I forgo the occasional anxiety and proceed with an heir of caution. To be sure, citizens globally are overwhelmingly disenchanted by their elected(sometimes) officials ability to deliver on their promises, but conversely praise technology for enlightening them of constitutional negligence. We have seen this throughout the world, and I would argue technology has been instrumental in creating greater transparency between governments and their citizens. The beneficiaries of the Arab Spring understand the tradeoffs between "privacy" and individual liberty all too well.

Thus the underlying problem may appear on the surface to reside in the evolution of technological innovation; in most cases the solution is never to regress; Voltaire is particularly enlightening here. The issue is fundamentally a societal one, coincidentally and irrevocably, we are living in a software dominated society. One answer is to go back in time--prior to our technologically dependent selves--to avoid the pitfalls of a more connected/less secure society. According to that logic, individuals were better off before they were inundated with fancy gadgets; life was simpler and society was more secure.  Conversely, I wholeheartedly believe that the tech industry is the best equipped to handle these issues. The answer is greater technological innovation, not an unrealistic nostalgia for the past.

I hope to return to this topic, which I think is worth exploring deeper, but in an effort to timebox myself I broadly covered only a few issues. Until part II...
</p>
</article>

<article>
   <header>
      <h1>T4 ENUMERABLE METHODS CHEAT SHEET </h1>

</header>
 <main>
  <div class="left">
    <h2>Enumerables? Each and Map</h2>
    <p> Enumerables is a module in Ruby, essentially a package of methods that includes iterators like each and map that allow the programmers to easily access elements and data stored in arrays and hashes. Each and Map in particular are exactly that, iterators that have the capability to sort through and array or hash, and manipulate each element in that collection according to the programmers needs.
    </p>


  </div>
  <div class="right">
  <h2>Compare Enumerables: Each & Map</h2>
    <ul><b>Each</b>
      <li>iterates</li>
      <li>loop through collection and print values</li>
      <li>will pass each element to the block specified</li>
      <li>will return the original collection</li>
      <li>ex.[1,2,3].each { |i| print "#{i}!"} => 1! 2! 3! => [1,2,3] </li>
    </ul>
      <ul><b>Map</b>
        <li>iterate</li>
        <li>loops through collection exactly like each</li>
        <li>automatically returns a new array containing values returned by the block</li>
        <li>use when you need a new array returned</li>
        <li>think of it as "re-mapping your original collection" to create a more specific version  </li>
      </ul>
    </div>

</article>

<article>
<h2>Tonight's Menu Featuring: A Cultural Journey</h2>
<div class="2">10 Oct 2014</div>
<hr>
<p>
  When applying to Dev Bootcamp, I sold myself as someone that is both a thinker and a do-er, which I believe is no longer the norm in our society. Certainly there are both thinkers and do-ers but rarely in my opinion do people straddle both.Indeed my generation (Y) is propitiously endowed with the ability to be both, but it is a concious choice not an inevitability. My intuition is that Dev Bootcamp's mission is not only to produce competent programmers, but more broadly,to amplify one's personal ambition, to be an architect providing the builder with certain tools and wisdom--inspiration and caution alike.
</p>
<p>
  My perception of Dev Bootcamp has certainly changed in recent weeks. While it is difficult not to view the intensive nature of the next 20 weeks as some form of a long term investment, my frame of mind is no longer focused on the outcome that will ensue afterwards. Rather, I am eager to see how elastic my bandwith for creation is and how far I can stretch my limits.
</p>
</div>
</article>
<article>
<h2>Gittin Jiggy With It</h2>
<div class="2">10 Oct 2014</div>
<hr>
<p>
  Anyone that has seen the movie Memento is familiar with the computer programming concept of "version control." Guy Pearce is Leonard Shelby, suffering from amnesia, relentlessly trying to piece together the events of a murder that resulted in the death of his wife and his subsequent memory loss. Leonard uses Polaroids with snippets of information written on the back to piece together the events of the traumatic robbery. Each photograph and accompanying blurb provides a snapshot into the structure of his life and relationships prior to his injury.
</p>
<p>
Similarly, computer programmers use a system called git, which provides an analogous snapshot into the various versions of the software they have written. Git is a local repository, meaning it is stored on your computer, that harbors all the necessary information for a programmer to be able to track the entire lifespan of their code. In this way, git allows programmers to save their work each time they commit changes to the larger piece while always allowing them to revert back to an earlier version. Thus git provides a medium for virtual time travel in the programming world. Each time the code is saved, a snapshot of the changes is recorded and a quick summary of the modifications accompanies each "commit" to make it easier to sift through several versions.
</p>
<p>
Programmers also benefit from an online repository called GitHub which works seamlessly with git on your computer to manage the many local versions on the computer with the master copy online. This invites teams working collaboratively on a project to continue to work independently without having to worry about potential "traffic jams," or overlaps. Thus GitHub serves as the final copy for any collaborative project and can be extremely beneficial when constantly iterating, resulting in a better product for the end user. Version control is merely one feature of git that makes it an incredibly useful tool for programmers.
</p>
</article>

</body>
</html>